#! /usr/bin/python2.7 
# -*- coding: utf8 -*-

import sys
import os, subprocess, shlex, re, gzip
# Just for DEBUG
#os.chdir('/Users/sofiasilva/GitHub/cool_bgp_stats')
from get_file import get_file
import bgp_rib
import pickle
import radix
from calendar import timegm
from datetime import datetime, date
import pandas as pd
from DBHandler import DBHandler
from time import time
import resource
from netaddr import IPNetwork

# For some reason in my computer os.getenv('PATH') differs from echo $PATH
# /usr/local/bin is not in os.getenv('PATH')
# it also works in matong
bgpdump = '/usr/local/bin/bgpdump'

class BGPDataHandler:
    DEBUG = False
    files_path = ''
  
    # STRUCTURES WITH CURRENT ROUTING DATA
  
    # DataFrame with routing data from routing files
    bgp_df = pd.DataFrame()
    
    # Radix indexed by routed IPv4 prefix containing the routing data from the
    # routing file being considered
    ipv4Prefixes_radix = radix.Radix()

    # Radix indexed by routed IPv6 prefix containing the routing data from the
    # routing file being considered
    ipv6Prefixes_radix = radix.Radix()

    # Numeric variable with the longest IPv4 prefix length
    ipv4_longest_pref = -1

    # Numeric variable with the longest IPv6 prefix length
    ipv6_longest_pref = -1  
    
    # DataFrame with summary for prefixes of BGP updates from bgpupd file
    updates_prefixes = pd.DataFrame()

    # DataFrame with summary for peerASes of BGP updates from bgpupd file
    updates_peerASes = pd.DataFrame()
    
    routingDate = ''
         
    # When we instantiate this class we set a boolean variable specifying
    # whether we will be working on DEBUG mode, we also set the variable with
    # the path to the folder we will use to store files (files_path) and
    # we set a boolean variable specifying whether we want to KEEP the
    # intermediate files generated by different functions
    def __init__(self, DEBUG, files_path):
        self.DEBUG = DEBUG
        self.files_path = files_path
        self.output_file = '{}/BGPDataHandler_{}.output'.format(files_path, date.today())

        sys.stdout.write("BGPDataHandler instantiated successfully! Remember to load the data structures.\n")
    
    
    # This function processes the routing data contained in the files to which
    # the URLs in the urls_file point, and loads the data structures of the class
    # with the results from this processing
    def loadStructuresFromURLSfile(self, urls_file):
        files_date, bgp_df, ipv4Prefixes_radix, ipv6Prefixes_radix,\
            ipv4_longest_pref, ipv6_longest_pref  =\
                        BGPDataHandler.processMultipleRoutingFiles(urls_file,
                                                                   False,
                                                                   True,
                                                                   self.files_path,
                                                                   self.DEBUG)
        
        aux_date = datetime.strptime('1970', '%Y').date()
        
        if files_date != aux_date and files_date is not None:
            self.routingDate = files_date

        if bgp_df.shape[0] != 0:
            self.bgp_df = bgp_df
            
        if len(ipv4Prefixes_radix.prefixes()) != 0:
            self.ipv4Prefixes_radix = ipv4Prefixes_radix
        
        if len(ipv6Prefixes_radix.prefixes()) != 0:
            self.ipv6Prefixes_radix = ipv6Prefixes_radix
        
        if ipv4_longest_pref != -1:
            self.ipv4_longest_pref = ipv4_longest_pref
        else:
            self.ipv4_longest_pref = 32

        if ipv6_longest_pref != -1:
            self.ipv6_longest_pref = ipv6_longest_pref
        else:
            self.ipv6_longest_pref = 64

        sys.stdout.write("Class data structures from files in URLs file were loaded successfully!\n")
        return True
            
    # This function processes the routing data contained in the routing_file
    # and loads the corresponding variables of the class with
    # the results from this processing                                           
    def loadStructuresFromRoutingFile(self, routing_file):
        if not routing_file.endswith('readable'):
            readable_file_name =  BGPDataHandler.getReadableFile(routing_file,
                                                                 False,
                                                                 self.files_path,
                                                                 self.DEBUG)
        else:
            readable_file_name = routing_file
        
        bgp_df = pd.DataFrame()
        ipv4Prefixes_radix = radix.Radix()
        ipv6Prefixes_radix = radix.Radix()
        
        if readable_file_name != '':
            routing_date, bgp_df, ipv4Prefixes_radix, ipv6Prefixes_radix,\
                ipv4_longest_pref, ipv6_longest_pref =\
                                    BGPDataHandler.processReadableDF(readable_file_name,
                                                                       bgp_df,
                                                                       ipv4Prefixes_radix,
                                                                       ipv6Prefixes_radix,
                                                                       self.DEBUG)
        
            self.routingDate = routing_date 
            self.bgp_df = bgp_df             
            self.ipv4Prefixes_radix = ipv4Prefixes_radix
            self.ipv6Prefixes_radix = ipv6Prefixes_radix
            
            if ipv4_longest_pref != -1:
                self.ipv4_longest_pref = ipv4_longest_pref
            else:
                self.ipv4_longest_pref = 32
            if ipv6_longest_pref != -1:
                self.ipv6_longest_pref = ipv6_longest_pref
            else:
                self.ipv6_longest_pref = 64
    
            sys.stdout.write("Class data structures were loaded successfully with info from routing file!\n")
            return True
        else:
            sys.stderr.write("Could not process routing file.\n")
            return False


    # This function loads the data structures of the class with the routing
    # data contained in the archive folder corresponding to the routing
    # date provided or to the most recent date present in the archive
    def loadStructuresFromArchive(self, routing_date=''):
        
        if routing_date == '':
            db_handler = DBHandler('')
            routing_files  =\
                        db_handler.getPathsToMostRecentRoutingFiles()
            db_handler.close()
        
            if len(routing_files) == 0:
                sys.stderr.write("There are no files in the archive!\n")
                return False
                
        else:
            db_handler = DBHandler('')
            routing_files = db_handler.getPathsToRoutingFilesForDate(routing_date)
            db_handler.close()
                                                          
            if len(routing_files) == 0:
                sys.stderr.write("There are no paths to routing files for the date provided in the DB.\n")
                return False

        bgprib_file = []
        dmp_files = []        
        for extension in routing_files:
            if extension == 'bgprib.mrt':
                bgprib_file.append(routing_files[extension])
                break
            else: # extension == 'dmp.gz' or extension == 'v6.dmp.gz'
                dmp_files.append(routing_files[extension])
        
        # If a bgprib file is available, we use it
        if len(bgprib_file) > 0:
            routing_files = bgprib_file
        #If not, we use the dmp files
        else:
            routing_files = dmp_files
                    
        files_date, bgp_df, ipv4Prefixes_radix, ipv6Prefixes_radix,\
            ipv4_longest_pref, ipv6_longest_pref  =\
                        BGPDataHandler.processMultipleRoutingFiles(routing_files,
                                                                    True,
                                                                    False,
                                                                    self.files_path,
                                                                    self.DEBUG)
        
        aux_date = datetime.strptime('1970', '%Y').date()

        if files_date != aux_date and files_date is not None:
            routing_loaded = True
            
            self.routingDate = files_date
            
            updates_loaded = self.loadUpdatesDFs(files_date)

        if bgp_df.shape[0] != 0:
            self.bgp_df = bgp_df
            
        if len(ipv4Prefixes_radix.prefixes()) != 0:
            self.ipv4Prefixes_radix = ipv4Prefixes_radix
            
        if len(ipv6Prefixes_radix.prefixes()) != 0:
            self.ipv6Prefixes_radix = ipv6Prefixes_radix
        
        if ipv4_longest_pref != -1:
            self.ipv4_longest_pref = ipv4_longest_pref
        else:
            self.ipv4_longest_pref = 32

        if ipv6_longest_pref != -1:
            self.ipv6_longest_pref = ipv6_longest_pref
        else:
            self.ipv6_longest_pref = 64

        if routing_loaded and updates_loaded:            
            sys.stdout.write("Class data structures were loaded successfully!\n")            
            return True
        else:
            return False
        
    # This function gets the summaries of updates for the specified date
    # for prefixes and for peer ASes from the DB
    # and loads the updates_prefixes and updates_peerASes class variables
    def loadUpdatesDFs(self, updates_date):
        db_handler = DBHandler('')
        self.updates_prefixes = db_handler.getUpdatesDF_prefix(updates_date)
        self.updates_peerASes = db_handler.getUpdatesDF_peerAS(updates_date)
        db_handler.close()
        return True        

    
    @staticmethod
    def getDateFromFileName(filename):
        
        dates = re.findall('(?P<year>[1-2][9,0][0,1,8,9][0-9])[-_]*(?P<month>[0-1][0-9])[-_]*(?P<day>[0-3][0-9])',\
                    filename)
                    
        if len(dates) > 0:
            file_date = '{}{}{}'.format(dates[0][0], dates[0][1], dates[0][2])
            return datetime.strptime(file_date, '%Y%m%d').date()
        else:
            return None

    
    @staticmethod
    def cleanListOfASes(ases_list, DEBUG, output_file):
        start = time()
        cleanListOfASes_list = []
        for asn in ases_list:
            if asn is None or asn == 'nan':
                continue
            elif '{' in str(asn):
                cleanListOfASes_list.extend(BGPDataHandler.cleanListOfASes(\
                                                    asn.replace('{', '').\
                                                    replace('}', '').split(','),
                                                    DEBUG, output_file))
            elif '(' in str(asn):
                cleanListOfASes_list.extend(BGPDataHandler.cleanListOfASes(\
                                                    asn.replace('(', '').\
                                                    replace(')', '').split(','),
                                                    DEBUG, output_file))
            # If an ASN is in asdot format we convert it to asplain format
            elif '.' in asn:
                left, right= asn.split('.')
                cleanListOfASes_list.append(str(int(left) * 65536 + int(right)))
            # If the asn contains a bracket ({) or parenthesis ((),
            # it is an as-set, therefore, we split it (leaving the brackets out)
            # and consider each AS separately.
            else:
                cleanListOfASes_list.append(asn)
        
        cleanListOfASes_list = list(set(cleanListOfASes_list))
        end = time()
        
        if DEBUG:
            with open(output_file, 'a') as output:
                output.write('Clean the list of ASes|{}|seconds\n'.format(end-start))

        return cleanListOfASes_list

    
    # This function returns a list of prefixes for which the routing_file has
    # announcements, a list of the origin ASes included in the routing_file,
    # a list of the middle ASes included in the routing file
    # and the date of the routing file.
    # The routing file is assumed to include routing data for a single day,
    # therefore the date is taken from the timestamp of the first row in the
    # bgp_df DataFrame.
    @staticmethod
    def getPrefixesASesAndDate(routing_file, files_path, DEBUG, output_file):
        sys.stdout.write("Getting lists of prefixes, origin ASes and middle ASes from {}\n".format(routing_file))

        start = time()
        if not routing_file.endswith('readable'):
            readable_file_name = BGPDataHandler.getReadableFile(routing_file,
                                                                False,
                                                                files_path,
                                                                DEBUG)
        else:
            readable_file_name = routing_file
        end = time()
        
        if DEBUG:
            with open(output_file, 'a') as output:
                output.write('Get a readable file|{}|seconds\n'.format(end-start))
        
            BGPDataHandler.printUsage(output_file)
        
        if readable_file_name == '':
            return [], [], ''

        start = time()
        bgp_df = pd.read_table(readable_file_name, header=None, sep='|',\
                                index_col=False, usecols=[1,3,5,6,7],\
                                names=['timestamp',\
                                        'peer',\
                                        'prefix',\
                                        'ASpath',\
                                        'origin'])
        end = time()

        if DEBUG:        
            with open(output_file, 'a') as output:
                output.write('Load the readable file into a DataFrame|{}|seconds\n'.format(end-start))
        
            BGPDataHandler.printUsage(output_file)
        
        if DEBUG:
            bgp_df = bgp_df[0:10]

        if bgp_df.shape[0] > 0:        
            start = time()
            routing_date = datetime.utcfromtimestamp(max(bgp_df['timestamp'])).date()
            
            # To get the origin ASes and middle ASes we split the ASpath column
            paths_parts = bgp_df.ASpath.str.rsplit(' ', n=1, expand=True)
    
            prefixes = set(bgp_df['prefix'])
            originASes = set(paths_parts[1])
            middleASes = set([item for sublist in paths_parts[0].tolist() for item in\
                            str(sublist).split()])
            end = time()
            
            if DEBUG:
                with open(output_file, 'a') as output:
                    output.write('Get the lists of prefixes, origin ASes and middle ASes from the DataFrame|{}|seconds\n'.format(end-start))
            
                BGPDataHandler.printUsage(output_file)
            
            return prefixes,\
                BGPDataHandler.cleanListOfASes(originASes, DEBUG, output_file),\
                BGPDataHandler.cleanListOfASes(middleASes, DEBUG, output_file),\
                routing_date
        else:
            return {}, {}, {}, None
            
        
    # This function downloads and processes all the routing files in the provided list.
    # The boolean variable containsURLs must be True if the files_list is a list
    # of URLs or False if it is a list of paths
    @staticmethod
    def processMultipleRoutingFiles(files_list, isList, containsURLs,
                                    files_path, DEBUG):
        if not isList:
            files_list = open(files_list, 'r')
   
        bgp_df = pd.DataFrame() 
        ipv4Prefixes_radix = radix.Radix()
        ipv6Prefixes_radix = radix.Radix()
        ipv4_longest_pref = -1
        ipv6_longest_pref = -1
        routingDate = datetime.strptime('1970', '%Y').date()
        
        i = 0
        for line in files_list:
            line = line.strip()
            if not line.startswith('#') and line != '':
                # If we work with several routing files
                sys.stdout.write("Starting to work with %s\n" % line)

                # We obtain partial data structures
                if containsURLs:
                    if not line.endswith('readable'):
                        readable_file_name =  BGPDataHandler.getReadableFile(\
                                                                        line,
                                                                        True,
                                                                        files_path,
                                                                        DEBUG)          
                    
                        if readable_file_name == '':
                            continue
                    else:
                        readable_file_name = line.strip()
                    
                else:
                    if not line.endswith('readable'):
                        readable_file_name =  BGPDataHandler.getReadableFile(\
                                                                        line,
                                                                        False,
                                                                        files_path,
                                                                        DEBUG)
                    
                        if readable_file_name == '':
                            continue
                    else:
                        readable_file_name = line.strip()
                
                file_date, bgp_df, ipv4Prefixes_radix, ipv6Prefixes_radix,\
                    ipv4_longest_pref_partial, ipv6_longest_pref_partial =\
                            BGPDataHandler.processReadableDF(readable_file_name,
                                                               bgp_df,
                                                               ipv4Prefixes_radix,
                                                               ipv6Prefixes_radix,
                                                               DEBUG)
                                                   
                if file_date is not None and file_date > routingDate:
                    routingDate = file_date
                        
                if ipv4_longest_pref_partial > ipv4_longest_pref:
                    ipv4_longest_pref = ipv4_longest_pref_partial
                    
                if ipv6_longest_pref_partial > ipv6_longest_pref:
                    ipv6_longest_pref = ipv6_longest_pref_partial
                        
            i += 1
            if DEBUG and i > 1:
                break

        if not isList:        
            files_list.close()
        
        return routingDate, bgp_df, ipv4Prefixes_radix, ipv6Prefixes_radix,\
                ipv4_longest_pref, ipv6_longest_pref
    
        
    # This function converts a file containing the output of the 'show ip bgp' command
    # to a file in the same format used for BGPDump outputs
    @staticmethod
    def convertBGPoutput(routing_file, onlyFirstLine, output_file_name, DEBUG):
        if not onlyFirstLine:
            output_file = open(output_file_name, 'w')
            
        i = 0
        # load routing table info  (the next loop does it automatically)
        for entry_n, bgp_entry in enumerate(bgp_rib.BGPRIB.parse_cisco_show_ip_bgp_generator(routing_file)):
            routing_date = bgp_entry[8]
#           date_part = str(file_date)[0:8]
#           time_part = str(file_date)[8:12]
            timestamp = str(timegm(datetime.strptime(routing_date, "%Y%m%d%H%M").timetuple()))
            next_hop = bgp_entry[2]
            prefix = bgp_entry[0]
            as_path = bgp_entry[6]
            
            if as_path:
                nextas = as_path[0]
            else:
            	nextas = ''

            if bgp_entry[7] == 'i':
                origin = "IGP"
            elif bgp_entry[7] == 'e':
                origin = "EGP"
            elif bgp_entry[7] == "?":
                origin = "INCOMPLETE"
            else:
                sys.stderr.write("Found invalid prefix at bgp entry %s, with content %s, on file %s\n" %(entry_n, bgp_entry, routing_file))
            	# ignore this line and continue
                continue

            # save information

            #the order for each line is
            #TABLE_DUMP2|date|B|nexthop|NextAS|prefix|AS_PATH|Origin
            line = 'TABLE_DUMP|'+timestamp+'|B|'+next_hop+'|'+nextas+'|'+prefix+'|'+" ".join(as_path)+'|'+origin+'\n'
            
            if onlyFirstLine:
                return line
            else:
                output_file.write(line)
    
            i += 1
            if DEBUG and i > 10:
                break
        
        if not onlyFirstLine:  
            output_file.close()
        else:
            # If we got here and onlyFirstLine is True, it means the dmp file is empty
            return ''
        
        return output_file_name
 
    # This function processes a readable file with routing info
    # putting all the info into a Data Frame
    @staticmethod
    def processReadableDF(readable_file_name, existing_bgp_df,
                          ipv4Prefixes_radix, ipv6Prefixes_radix, DEBUG):
        
        routing_date = None
        
        ipv4_longest_prefix = -1
        ipv6_longest_prefix = -1
        
        bgp_df = pd.read_table(readable_file_name, header=None, sep='|',\
                                index_col=False, usecols=[1,3,5,6,7],\
                                names=['timestamp',\
                                        'peer',\
                                        'prefix',\
                                        'ASpath',\
                                        'origin'])
        
        if bgp_df.shape[0] > 0:
        
            if DEBUG:
                bgp_df = bgp_df[0:10]

            # We take the most recent date of the routing file as the routing date
            # Typically the routing file will containg routing data for a single date
            routing_timestamp = max(bgp_df['timestamp'])
            routing_date = datetime.utcfromtimestamp(routing_timestamp).date()
            
            ASpath_parts = bgp_df.ASpath.str.rsplit(' ', n=1, expand=True)
            bgp_df['originAS'] = ASpath_parts[1]            
            bgp_df['middleASes'] = ASpath_parts[0]
           
            for prefix, prefix_subset in bgp_df.groupby('prefix'):
                network = IPNetwork(prefix)
                if network.version == 4:
                    if network.prefixlen > ipv4_longest_prefix:
                        ipv4_longest_prefix = network.prefixlen
                    prefixes_radix = ipv4Prefixes_radix
                    
                else:
                    if network.prefixlen > ipv6_longest_prefix:
                        ipv6_longest_prefix = network.prefixlen 
                    prefixes_radix = ipv6Prefixes_radix
                

                ASpaths = set(prefix_subset['ASpath'])
                originASes = set(prefix_subset['originAS'])
                
                node = prefixes_radix.search_exact(prefix)
                if node is None:
                    node = prefixes_radix.add(prefix)
                    node.data['ASpaths'] = ASpaths
                    node.data['OriginASes'] = originASes
                else:
                    node.data['ASpaths'] = node.data['ASpaths'].union(ASpaths)
                    node.data['OriginASes'] = node.data['OriginASes'].union(originASes)
                    
            sys.stdout.write('Finished loading Radix trees with prefixes.\n')
            
            bgp_df = pd.concat([existing_bgp_df, bgp_df])
            
        return routing_date, bgp_df, ipv4Prefixes_radix, ipv6Prefixes_radix,\
                ipv4_longest_prefix, ipv6_longest_prefix

    # This function downloads a routing file if the source provided is a URL
    # If the file is compressed, it is unzipped
    # and finally it is processed using BGPdump if the file is a MRTfile
    # or using the functions provided by get_rib.py is the file contains the
    # output of the 'show ip bgp' command
    # The path to the resulting readable file is returned
    @staticmethod
    def getReadableFile(source, isURL, files_path, DEBUG):

        compressed = False
        
        source_filename = source.split('/')[-1]
        
        readable_file_name = '{}/{}.readable'.format(files_path, os.path.splitext(source_filename)[0])

        if not os.path.exists(readable_file_name):
            # If a routing file is not provided, download it from the provided URL        
            if isURL:
                routing_file = '%s/%s' % (files_path, source_filename)
                get_file(source, routing_file)
                source = routing_file
            
            # If the routing file is compressed we unzip it
            if source.endswith('.gz'):
                compressed = True
                output_file = '%s/%s' % (files_path,\
                                    os.path.splitext(source)[0].split('/')[-1])
                
                if not os.path.exists(output_file):
                    with gzip.open(source, 'rb') as gzip_file,\
                        open(output_file, 'wb') as output:
                        try:
                            output.write(gzip_file.read())
                        except IOError:
                            return ''
                
                source = output_file
                source_filename = source.split('/')[-1]
        
            # If the routing file is a MRT file, we process it using BGPdump
            if source.endswith('mrt'):            
                cmd = shlex.split('%s -m -O %s %s' % (bgpdump, readable_file_name, source))
                #        cmd = shlex.split('bgpdump -m -O %s %s' % (readable_file_name, routing_file))   
        
                #  BGPDUMP
                #  -m         one-line per entry with unix timestamps
                #  -O <file>  output to <file> instead of STDOUT
        
                subprocess.call(cmd)
            
            # If the file contains the output of the 'show ip bgp' command,
            # we convert it to the same format used by BGPdump for its outputs
            else:
                readable_file_name = BGPDataHandler.convertBGPoutput(source,
                                                                     False,
                                                                     readable_file_name,
                                                                     DEBUG)

        if compressed:
            os.remove(output_file)
            
        return readable_file_name
        
    # This function downloads a routing file if the source provided is a URL
    # If the file is compressed, it is unzipped
    # and finally it is processed using BGPdump if the file is a MRTfile
    # or using the functions provided by get_rib.py if the file contains the
    # output of the 'show ip bgp' command
    # The first line of the file in readable format is returned
    @staticmethod
    def getReadableFirstLine(source, isURL, files_path, DEBUG):
    
        source_filename = source.split('/')[-1]
        compressed = False
        
        # If a routing file is not provided, download it from the provided URL        
        if isURL:
            routing_file = '%s/%s' % (files_path, source_filename)
            get_file(source, routing_file)
            source = routing_file
        
        # If the routing file is compressed we unzip it
        if source.endswith('.gz'):
            compressed = True
            output_file = '%s/%s' % (files_path,\
                                os.path.splitext(source)[0].split('/')[-1])
            
            with gzip.open(source, 'rb') as gzip_file,\
                open(output_file, 'wb') as output:
                try:
                    output.write(gzip_file.read())
                except IOError:
                    return ''
            
            source = output_file
            source_filename = source.split('/')[-1]

        # If the routing file is a MRT file, we process it using BGPdump
        if source.endswith('mrt'):            
            cmd = shlex.split('{} -m {}'.format(bgpdump, source))
            #        cmd = shlex.split('bgpdump -m -O %s %s' % (readable_file_name, routing_file))   
    
            #  BGPDUMP
            #  -m         one-line per entry with unix timestamps
            #  -O <file>  output to <file> instead of STDOUT
    
            p1 = subprocess.Popen(cmd, stdout=subprocess.PIPE)
            
            cmd2 = shlex.split('head -1')
            first_line = subprocess.check_output(cmd2, stdin=p1.stdout)
            p1.kill()
        
        # If the file contains the output of the 'show ip bgp' command,
        # we convert it to the same format used by BGPdump for its outputs
        else:
            first_line = BGPDataHandler.convertBGPoutput(source, True, '', DEBUG)
            
        if compressed:
            os.remove(output_file)

        return first_line
        
    # This function sets the ipv4_longest_pref and ipv6_longest_pref class variables
    # with the corresponding maximum prefix lengths in the ipv4_prefixes_indexes
    # and ipv6_prefixes_indexes Radixes
    def setLongestPrefixLengths(self):
        for prefix in self.ipv4_prefixes_indexes_radix.prefixes():
            network = IPNetwork(prefix)
            
            if network.prefixlen > self.ipv4_longest_pref:
                self.ipv4_longest_pref = network.prefixlen
                
        for prefix in self.ipv6_prefixes_indexes_radix.prefixes():
            network = IPNetwork(prefix)

            if network.prefixlen > self.ipv6_longest_pref:
                self.ipv6_longest_pref = network.prefixlen
                
    # This function returns a list of prefixes less specific than the one provided
    # that are included in the keys of the corresponding Radix
    def getRoutedParentAndGrandparents(self, network):        
        if network.version == 4:
            prefixes_radix = self.ipv4Prefixes_radix
        else:
            prefixes_radix = self.ipv6Prefixes_radix
            
        less_specifics = []
       
        for less_spec_node in prefixes_radix.search_covering(str(network)):
            less_spec_pref = less_spec_node.prefix
        
            if less_spec_pref != str(network):
                less_specifics.append(less_spec_pref)
            
        return less_specifics
    
    # This function returns a list of prefixes more specific than the one provided
    # that are included in the keys of the corresponding Radix
    def getRoutedChildren(self, network):
        if network.version == 4:
            prefixes_radix = self.ipv4Prefixes_radix
        else:
            prefixes_radix = self.ipv6Prefixes_radix
            
        more_specifics = []
       
        for more_spec_node in prefixes_radix.search_covered(str(network)):
            more_specifics.append(more_spec_node.prefix)
                        
        return more_specifics
        
    # This function returns the origin AS for a specific prefix
    # according to the routing data included in the BGP_data class variable
    def getOriginASesForBlock(self, network):        
        if network.version == 4:
            prefixes_radix = self.ipv4Prefixes_radix
        else:
            prefixes_radix = self.ipv6Prefixes_radix

        pref_node = prefixes_radix.search_exact(str(network))
        if pref_node is not None:
            return set(pref_node.data['OriginASes'])
        else:
            return set()
    
    # This function returns a set with all the AS paths for a specific prefix
    # according to the routing data included in the BGP_data class variable
    def getASpathsForBlock(self, network):
        if network.version == 4:
            prefixes_radix = self.ipv4Prefixes_radix
        else:
            prefixes_radix = self.ipv6Prefixes_radix
            
        pref_node = prefixes_radix.search_exact(str(network))
        if pref_node is not None:
            return pref_node.data['ASpaths']
        else:
            return set()
    
    
    @staticmethod
    def printUsage(output_file):
        usage = resource.getrusage(resource.RUSAGE_SELF)
    
        '''
        Index	Field	Resource
        0	ru_utime	time in user mode (float)
        1	ru_stime	time in system mode (float)
        2	ru_maxrss	maximum resident set size
        3	ru_ixrss	shared memory size
        4	ru_idrss	unshared memory size
        5	ru_isrss	unshared stack size
        6	ru_minflt	page faults not requiring I/O
        7	ru_majflt	page faults requiring I/O
        8	ru_nswap	number of swap outs
        9	ru_inblock	block input operations
        10	ru_oublock	block output operations
        11	ru_msgsnd	messages sent
        12	ru_msgrcv	messages received
        13	ru_nsignals	signals received
        14	ru_nvcsw	voluntary context switches
        15	ru_nivcsw	involuntary context switches
        '''
    
        with open(output_file, 'a') as output:
            for name, desc in [
                ('ru_utime', 'User time'),
                ('ru_stime', 'System time'),
                ('ru_maxrss', 'Max. Resident Set Size'),
                ('ru_ixrss', 'Shared Memory Size'),
                ('ru_idrss', 'Unshared Memory Size'),
                ('ru_isrss', 'Stack Size'),
                ('ru_nswap', 'Num. of Swap outs'),
                ('ru_inblock', 'Block inputs'),
                ('ru_oublock', 'Block outputs'),
                ]:
                output.write('{} ({})|{}\n'.format(desc, name, getattr(usage, name)))

    @staticmethod
    def getDateFromReadableFile(file_path, output_file):
        with open(file_path, 'rb') as readable_file:
            first_line = readable_file.readline()
            
            try:
                timestamp = float(first_line.split('|')[1])
                return datetime.utcfromtimestamp(timestamp).date()
            except IndexError:
                timestamp = ''
                for i in range(5):
                    line = readable_file.readline()
                    try:
                        timestamp = float(line.split('|')[1])
                        break
                    except IndexError:
                        continue
                
                if timestamp == '':
                    with open(output_file, 'a') as output:
                        output.write('Cannot get date from content of file {}\n'.format(file_path))
                        
                        file_size = os.path.getsize(file_path)
                        if file_size == 0:
                            output.write('File {} is empty. Deleting it.\n'.format(file_path))
                            os.remove(file_path)
                    return None
                else:
                    return datetime.utcfromtimestamp(timestamp).date()
    
                    
    # We assume the routing files have routing info for a single date,
    # therefore we get the routing date from the first line of the file.
    @staticmethod
    def getDateFromFile(file_path, output_file, files_path, DEBUG):
        if 'readable' in file_path:       
            return BGPDataHandler.getDateFromReadableFile(file_path, output_file)
    
        else:
            first_line = BGPDataHandler.getReadableFirstLine(file_path, False,
                                                             files_path, DEBUG)
            
            try:
                timestamp = float(first_line.split('|')[1])
                return datetime.utcfromtimestamp(timestamp).date()
                
            except IndexError:
                readable_file = BGPDataHandler.getReadableFile(file_path, False,
                                                               files_path, DEBUG)
                                                               
                return BGPDataHandler.getDateFromReadableFile(readable_file,
                                                              output_file)
